name: CI

on:
  push:
    branches: [main, master]
  pull_request:
    branches: [main, master]

jobs:
  # Plain Caddy, no modules, native Linux
  build-plain:
    name: Plain (no modules)
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: ./
        id: build
        with:
          caddy-version: v2.10.2
      - run: |
          test -f "${{ steps.build.outputs.caddy-path }}"
          ${{ steps.build.outputs.caddy-path }} version
          test "${{ steps.build.outputs.goos }}" = "linux"
          test "${{ steps.build.outputs.goarch }}" = "amd64"
          test "${{ steps.build.outputs.caddy-name }}" = "caddy_linux_amd64"

  # Modules with comma/newline and module@version
  build-modules:
    name: Modules (formats)
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: ./
        id: build
        with:
          caddy-version: v2.10.2
          modules: |
            github.com/caddy-dns/cloudflare
            github.com/caddyserver/ntlm-transport@v0.1.1
      - run: |
          test -f "${{ steps.build.outputs.caddy-path }}"
          ${{ steps.build.outputs.caddy-path }} list-modules | grep -q cloudflare
          ${{ steps.build.outputs.caddy-path }} list-modules | grep -q http_ntlm

  # Custom output-dir
  build-output-dir:
    name: Custom output-dir
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: ./
        id: build
        with:
          caddy-version: v2.10.2
          output-dir: ./dist
      - run: |
          test -f "${{ steps.build.outputs.caddy-path }}"
          test -f ./dist/caddy_linux_amd64

  # Embed directory
  build-embeds:
    name: Embeds
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - run: mkdir -p embeddir && echo "test" > embeddir/file.txt
      - uses: ./
        id: build
        with:
          caddy-version: v2.10.2
          embeds: embeddir
      - run: test -f "${{ steps.build.outputs.caddy-path }}"

  # Caddy latest (no pinned version)
  build-latest:
    name: Caddy latest
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: ./
        id: build
        with:
          caddy-version: latest
          modules: github.com/caddy-dns/cloudflare
      - run: |
          test -f "${{ steps.build.outputs.caddy-path }}"
          ${{ steps.build.outputs.caddy-path }} version

  # Cross-compile: Linux -> Windows
  build-cross-windows:
    name: Cross (→ Windows)
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: ./
        id: build
        with:
          goos: windows
          goarch: amd64
          caddy-version: v2.10.2
          modules: github.com/caddy-dns/cloudflare
      - run: |
          test -f "${{ steps.build.outputs.caddy-path }}"
          test "${{ steps.build.outputs.caddy-name }}" = "caddy_windows_amd64.exe"
          test "${{ steps.build.outputs.goos }}" = "windows"
          test "${{ steps.build.outputs.goarch }}" = "amd64"

  # Cross-compile: Linux -> macOS
  build-cross-darwin:
    name: Cross (→ macOS)
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: ./
        id: build
        with:
          goos: darwin
          goarch: arm64
          caddy-version: v2.10.2
          modules: github.com/caddy-dns/cloudflare
      - run: |
          test -f "${{ steps.build.outputs.caddy-path }}"
          test "${{ steps.build.outputs.caddy-name }}" = "caddy_darwin_arm64"
          test "${{ steps.build.outputs.goos }}" = "darwin"
          test "${{ steps.build.outputs.goarch }}" = "arm64"

  # Native build on Windows
  build-native-windows:
    name: Native Windows
    runs-on: windows-latest
    steps:
      - uses: actions/checkout@v4
      - uses: ./
        id: build
        with:
          caddy-version: v2.10.2
          modules: github.com/caddy-dns/cloudflare
      - run: |
          test -f "${{ steps.build.outputs.caddy-path }}"
          "${{ steps.build.outputs.caddy-path }}" version
          "${{ steps.build.outputs.caddy-path }}" list-modules | grep -q cloudflare
        shell: bash

  # Native build on macOS
  build-native-macos:
    name: Native macOS
    runs-on: macos-latest
    steps:
      - uses: actions/checkout@v4
      - uses: ./
        id: build
        with:
          caddy-version: v2.10.2
          modules: github.com/caddy-dns/cloudflare
      - run: |
          test -f "${{ steps.build.outputs.caddy-path }}"
          ${{ steps.build.outputs.caddy-path }} version
          ${{ steps.build.outputs.caddy-path }} list-modules | grep -q cloudflare

  # Native Linux ARM64 (if runner available)
  build-native-linux-arm64:
    name: Native Linux ARM64
    runs-on: ubuntu-22.04-arm
    steps:
      - uses: actions/checkout@v4
      - uses: ./
        id: build
        with:
          caddy-version: v2.10.2
          modules: github.com/caddy-dns/cloudflare
      - run: |
          test -f "${{ steps.build.outputs.caddy-path }}"
          ${{ steps.build.outputs.caddy-path }} version
          test "${{ steps.build.outputs.goarch }}" = "arm64"

  # Create release after all tests pass (main branch only)
  release:
    name: Release
    runs-on: ubuntu-latest
    needs:
      - build-plain
      - build-modules
      - build-output-dir
      - build-embeds
      - build-latest
      - build-cross-windows
      - build-cross-darwin
      - build-native-windows
      - build-native-macos
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    permissions:
      contents: write
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Compute next version from tags
        id: version
        run: |
          git fetch --tags 2>/dev/null || true

          # Get latest tag matching vMAJOR.MINOR.PATCH (e.g. v1.2.3)
          PREV_TAG=$(git tag -l 'v*.*.*' 2>/dev/null | sort -V | tail -1)

          if [ -z "$PREV_TAG" ]; then
            # No previous tag: start at 1.0.0
            NEW_TAG="v1.0.0"
            PREV_TAG_FOR_NOTES=""
          else
            # Parse major.minor.patch (strip leading v)
            VER="${PREV_TAG#v}"
            MAJOR=$(echo "$VER" | cut -d. -f1)
            MINOR=$(echo "$VER" | cut -d. -f2)
            PATCH=$(echo "$VER" | cut -d. -f3)

            # Bump patch; if patch was 9, wrap to 0 and bump minor; if minor was 9, wrap to 0 and bump major
            PATCH=$((PATCH + 1))
            if [ "$PATCH" -gt 9 ]; then
              PATCH=0
              MINOR=$((MINOR + 1))
              if [ "$MINOR" -gt 9 ]; then
                MINOR=0
                MAJOR=$((MAJOR + 1))
              fi
            fi

            NEW_TAG="v${MAJOR}.${MINOR}.${PATCH}"
            PREV_TAG_FOR_NOTES="$PREV_TAG"
          fi

          echo "new_tag=$NEW_TAG" >> $GITHUB_OUTPUT
          echo "prev_tag=$PREV_TAG_FOR_NOTES" >> $GITHUB_OUTPUT

      - name: Skip if no new commits since last tag
        id: should_release
        run: |
          PREV="${{ steps.version.outputs.prev_tag }}"
          if [ -z "$PREV" ]; then
            # First release, always create
            echo "should_release=true" >> $GITHUB_OUTPUT
            exit 0
          fi
          PREV_COMMIT=$(git rev-parse "$PREV" 2>/dev/null || echo "")
          if [ -z "$PREV_COMMIT" ]; then
            echo "should_release=true" >> $GITHUB_OUTPUT
            exit 0
          fi
          if [ "$(git rev-parse HEAD)" = "$PREV_COMMIT" ]; then
            echo "should_release=false" >> $GITHUB_OUTPUT
          else
            echo "should_release=true" >> $GITHUB_OUTPUT
          fi

      - name: Build release notes
        if: steps.should_release.outputs.should_release == 'true'
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          NEW_TAG="${{ steps.version.outputs.new_tag }}"
          PREV_TAG="${{ steps.version.outputs.prev_tag }}"
          REPO="${{ github.repository }}"

          # Get auto-generated notes from GitHub API
          if [ -n "$PREV_TAG" ]; then
            BODY=$(gh api "repos/${REPO}/releases/generate-notes" \
              -f tag_name="$NEW_TAG" \
              -f target_commitish="${{ github.sha }}" \
              -f previous_tag_name="$PREV_TAG" \
              --jq '.body')
          else
            BODY=$(gh api "repos/${REPO}/releases/generate-notes" \
              -f tag_name="$NEW_TAG" \
              -f target_commitish="${{ github.sha }}" \
              --jq '.body')
          fi

          # Get commits: title as header, description as sub-items
          if [ -n "$PREV_TAG" ]; then
            COMMITS=$(git log "$PREV_TAG..HEAD" --no-merges --format='### %s%n%b')
          else
            COMMITS=$(git log --no-merges --format='### %s%n%b')
          fi

          # Combine: auto-generated + commits (no extra section title)
          {
            echo "$BODY"
            echo ""
            echo "---"
            echo ""
            echo "$COMMITS"
          } > release_notes.md

      - name: Create release
        if: steps.should_release.outputs.should_release == 'true'
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          NEW_TAG="${{ steps.version.outputs.new_tag }}"
          gh release create "$NEW_TAG" \
            --title "$NEW_TAG" \
            --target "${{ github.sha }}" \
            --notes-file release_notes.md
